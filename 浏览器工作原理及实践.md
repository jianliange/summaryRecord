# 开篇
- 如果你要开发流畅的页面，或者诊断 Web 页面中的性能问题，那你就需要了解 `URL 是怎么变成页面的`，只有弄懂这些之后，你才可以站在全局的角度定位问题或者写出高效的代码。
- 可以把`浏览器`看成一个黑盒，左边输入一个 URL，经过黑盒处理之后，右边返回你预期的效果
- `首屏的显示`就涉及了 DNS、HTTP、DOM 解析、CSS 阻塞、JavaScript 阻塞等技术因素，其中一项没处理好就可能导致整个页面的延时。
# 宏观视角下的浏览器
## 01 | Chrome架构：仅仅打开了1个页面，为什么有4个进程？
- 想要设计高性能 Web 应用，还是要优化现有的 Web 应用，需要了解浏览器中的`网络流程`、`页面渲染过程`，`JavaScript 执行流程`，以及 `Web 安全理论`。
### 并行处理
- 单线程：按顺序执行任务
- 多线程（并行处理）：同一时刻处理多个任务
# 进程
- `线程是不能单独存在的，它是由进程来启动和管理的`
- `一个进程就是一个程序的运行实例`。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫`进程`。
### 进程和线程
- 1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。
- 2. 线程之间共享进程中的数据。
- 3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。（当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。）
- 4. 进程之间的内容相互隔离。

- 如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了。

### 单进程浏览器时代
- `指浏览器的所有功能模块都是运行在同一个进程里`，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。
- 用浏览器打开多个页面时，突然某个页面崩溃了或者失去响应，随之而来的是整个浏览器的崩溃或者无响应
### 多进程浏览器时代
- 优点：多进程模型提升了浏览器的稳定性、流畅性和安全性。
- `更高的资源占用`。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。
- `更复杂的体系架构`。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。
### 未来面向服务的架构
- 在 2016 年，Chrome 官方团队使用“`面向服务的架构`”（Services Oriented Architecture，简称 `SOA`）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，`访问服务（Service）必须使用定义好的接口`，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。

## 02 | TCP协议：如何保证页面文件能被完整送达浏览器？
- 在衡量 Web 页面性能的时候有一个重要的指标叫“`FP（First Paint）`”，是`指从页面加载到首次开始绘制的时长`。
- 影响 FP 指标：其中一个重要的因素是`网络加载速度`。
### 一个数据包的“旅程”
- `互联网，实际上是一套理念和协议组成的体系架构。`其中，协议是一套众所周知的规则和标准，如果各方都同意使用，那么它们之间的通信将变得毫无障碍。
#### 1. IP：把数据包送达目的主机
- `网际协议（Internet Protocol，简称 IP）`
- `计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。`
- `IP 头是` IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息
#### 2. UDP：把数据包送达应用程序
- IP只负责将数据包传到对方电脑，而交给那个程序，需要需要基于 IP 之上开发能和应用打交道的协议，最常见的是“`用户数据包协议`（User Datagram Protocol）”，简称 `UDP`。
- IP 通过 IP 地址信息把数据包发送给指定的电脑，而 `UDP 通过``端口号``把数据包分发给正确的程序`
- `UDP 头`中除了目的端口，还有源端口号等信息
- `UDP 不能保证数据可靠性`，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。
#### 3. TCP：把数据完整地送达应用程序
对于浏览器请求，或者邮件这类要求数据传输可靠性（reliability）的应用，如果使用 UDP 来传输会存在两个问题：
- 数据包在传输过程中容易丢失；
- 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。

- `TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。`相对于 UDP，TCP 有下面两个特点:
- 对于数据包丢失的情况，TCP 提供重传机制；
- TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

`TCP 头`除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包

一个完整的 TCP 连接的生命周期包括了“`建立连接`”“`传输数据`”和“`断开连接`”三个阶段。

- `建立连接阶段`。这个阶段是通过“`三次握手`”来建立客户端和服务器之间的连接。
`三次握手`，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。
- `传输数据阶段`。在该阶段，`接收端需要对每个数据包进行确认操作`，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为`数据包丢失`，并触发发送端的`重发机制`。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会`按照 TCP 头中的序号为其排序`，从而保证组成`完整的数据`。
- `断开连接阶段`。“四次挥手”来保证双方都能断开连接。

`TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度`，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。

## 03 | HTTP请求流程：为什么很多站点第二次打开速度会很快？
- HTTP 协议，正是建立在 TCP 连接基础之上的。`HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础`，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。此外，`HTTP 也是浏览器使用最广的协议`。
- `DNS 缓存`和`页面资源缓存`这两块数据是会被浏览器缓存的。其中，DNS 缓存比较简单，它主要就是在浏览器本地把对应的 IP 和域名关联起来.
- `浏览器缓存数据`:当服务器返回 `HTTP 响应头`给浏览器时，浏览器是`通过响应头中的 Cache-Control 字段来设置是否缓存该资源`。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比如上图设置的缓存过期时间是 2000 秒。
- 服务器收到请求头后，会根据 `If-None-Match`(If-None-Match:"4f80f-13c-3a1xb12a")的值来判断请求的资源是否有更新。如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”如果资源有更新，服务器就直接返回最新资源给浏览器。


### 浏览器端发起HTTP请求流程
#### 1.构建请求
浏览器构建`请求行`信息
```js
GET /index.html HTTP1.1
```
#### 2.查找缓存
- 在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件
- `浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。`

#### 3. 准备 IP 地址和端口
- 浏览器使用 `HTTP 协议作为应用层协议`，用来封装请求的文本信息；并使用 `TCP/IP 作传输层协议`将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 `HTTP 的内容是通过 TCP 的传输数据阶段来实现的`。
- 极客时间网站的 IP 是 39.106.233.176,  难以记忆，但使用极客时间的域名（time.geekbang.org）就好记多了，所以基于这个需求又出现了一个服务,负责把域名和 IP 地址做一一映射关系。这套域名映射为 IP 的系统就叫做“`域名系统`”，简称 `DNS`（Domain Name System）。
- 第一步浏览器会请求 DNS 返回域名对应的 IP
- 浏览器还提供了 `DNS 数据缓存服务`
- 拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。

#### 4. 等待 TCP 队列
Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。
#### 5. 建立 TCP 连接
#### 6. 发送 HTTP 请求
一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。

- 首先浏览器会向服务器发送`请求行`，它包括了`请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。`
### 服务器端处理 HTTP 请求流程
#### 1. 返回请求
可以通过工具软件 curl 来查看返回请求数据，`curl -i https://time.geekbang.org/`(-i是为了返回响应行、响应头和响应体的数据；-I表示只需要获取响应头和响应行数据，而不需要获取响应体的数据)
服务器也会随同响应向浏览器发送`响应头`。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。
发送完响应头后，服务器就可以继续发送`响应体`的数据，通常，响应体就包含了 HTML 的实际内容。
#### 2. 断开连接
通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：`Connection:Keep-Alive`。
那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。`保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度`。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。

#### 3. 重定向
响应行返回的状态码是 301，状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。

## 04 | 导航流程：从输入URL到页面展示，这中间发生了什么？
- `浏览器进程`主要负责用户交互、子进程管理和文件储存等功能。
- `网络进程`是面向渲染进程和浏览器进程等提供网络下载功能。
- `渲染进程`的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全。

- 首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。
- 然后，在网络进程中发起真正的 URL 请求。
- 接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。
- 浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程；
- 渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道；
- 最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。
- 浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。
这其中，`用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。`

## 05 | 渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？
- `HTML 的内容是由标记和文本组成`。标记也称为`标签`
- CSS 又称为`层叠样式表，是由选择器和属性组成`
- `JavaScript（简称为 JS），使用它可以使网页的内容“动”起来`
- 按照渲染的时间顺序，流水线可分为如下几个`子阶段`：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。
开始每个子阶段都有其`输入的内容`；然后每个子阶段有其`处理过程`；最终每个子阶段会生成`输出内容`。

在 HTML 页面内容被提交给渲染引擎之后，渲染引擎首先将 HTML 解析为浏览器可以理解的 DOM；然后根据 CSS 样式表，计算出 DOM 树所有节点的样式；接着又计算每个元素的几何坐标位置，并将这些信息保存在布局树中。

### 构建 DOM 树
- `因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。`
构建 DOM 树的`输入内容`是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。
### 样式计算（Recalculate Style）
#### 1. 把 CSS 转换为浏览器能够理解的结构
浏览器也是无法直接理解这些纯文本的 CSS 样式，所以`当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。`该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。
#### 2. 转换样式表中的属性值，使其标准化
CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以`需要将所有值转换为渲染引擎容易理解的、标准化的计算值`，这个过程就是属性值标准化。
#### 3. 计算出 DOM 树中每个节点的具体样式
`这就涉及到 CSS 的继承规则和层叠规则了。`
`CSS 继承`就是每个 DOM 节点都包含有父节点的样式
`层叠`是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。

如果你想了解每个 DOM 元素最终的计算样式，可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，然后再选择“Computed”子标签

### 布局阶段
`接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。`

Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。

#### 1. 创建布局树
你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以`在显示之前，我们还要额外地构建一棵只包含可见元素布局树`
#### 2. 布局计算
现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了

## 06 | 渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？
### 分层
因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，`渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树`（LayerTree）。如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。

`浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面`

通常情况下，`并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层`

通常满足下面两点中任意一点的元素就渲染引擎可以被提升为单独的一个图层。
- `第一点，拥有层叠上下文属性的元素会被提升为单独的一层。`
从图中可以看出，明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。
- `第二点，需要剪裁（clip）的地方也会被创建为图层。`
出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。

### 图层绘制
渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的`绘制指令`，然后再把这些指令按照顺序组成一个待绘制列表

### 栅格化（raster）操作
当图层的绘制列表准备好之后，主线程会把该绘制列表`提交`（commit）给合成线程
通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做`视口`（viewport）。
`合成线程会将图层划分为图块`（tile），这些图块的大小通常是 256x256 或者 512x512，然后`合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。`
### 合成和显示
一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

### 渲染流水线大总结
1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

### “重排”“重绘”和“合成”
#### 1. `更新了元素的几何属性（重排）`
如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，`重排需要更新完整的渲染流水线，所以开销也是最大的`。

#### 2. 更新元素的绘制属性（重绘）
如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，`重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。`
#### 3. 直接合成阶段
那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做`合成`。

减少重排重绘方法：
1. 使用 class 操作样式，而不是频繁操作 style
2. 避免使用 table 布局
3. 批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React
4. Debounce window resize 事件
5. 对 dom 属性的读写要分离
6. will-change: transform 做优化


# 浏览器中的JavaScript执行机制

## 07 | 变量提升：JavaScript代码是按顺序执行的吗？

### 变量提升（Hoisting）
所谓的变量提升，`是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分(var...)和函数的声明部分(function)提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。`
`函数和变量在执行之前都提升到了代码开头。`

### JavaScript 代码的执行流程
`实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中`
JavaScript 代码->`编译`->`执行`阶段。

#### 1. 编译阶段
`第一部分：变量提升部分的代码。`
`第二部分：执行部分的代码。`

输入一段代码，经过编译后，会生成两部分内容：`执行上下文（Execution context）和可执行代码。`
`执行上下文是 JavaScript 执行一段代码时的运行环境`，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等

在执行上下文中存在一个`变量环境的对象`（Viriable Environment），该对象中保存了变量提升的内容

#### 2. 执行阶段

#### 代码中出现相同的变量或者函数怎么办？
一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数。

下面是关于同名变量和函数的两点处理原则：

- 1:如果是同名的函数，JavaScript编译阶段会选择最后声明的那个。

- 2:如果变量和函数同名，那么在编译阶段，变量的声明会被忽略

## 08 | 调用栈：为什么JavaScript代码会出现栈溢出？
`调用栈``就是用来管理函数调用关系的一种数据结构`。因此要讲清楚调用栈，你还要先弄明白`函数调用`和`栈结构`。什么是函数调用

### 什么是函数调用
函数调用就是运行一个函数，具体使用方式是使用函数名称跟着一对小括号

JavaScript 引擎是如何管理这些执行上下文的呢？`通过一种叫栈的数据结构来管理的`

### 什么是栈
栈中的元素满足`后进先出`的特点

### 什么是 JavaScript 的调用栈
把这种用来管理执行上下文的栈称为`执行上下文栈`，又称`调用栈`。

在代码的执行过程中，调用栈的状态变化情况
1. 创建全局上下文，并将其压入栈底
2. 调用函数时，，JavaScript 引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中
3. 函数调用完毕，调用函数的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了

`调用栈是 JavaScript 引擎追踪函数执行的一个机制`，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。

### 在开发中，如何利用好调用栈
#### 1. 如何利用浏览器查看调用栈的信息
- 打断点的时候，面板中的“call stack”,显示出来了函数的调用关系：栈的最底部是 anonymous，也就是全局的函数入口；中间是 addAll 函数；顶部是 add 函数。这就清晰地反映了函数的调用关系，所以`在分析复杂结构代码，或者检查 Bug 时，调用栈都是非常有用的。`
- console.trace() 来输出当前的函数调用关系

#### 2. 栈溢出（Stack Overflow）
`调用栈是有大小的`，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做`栈溢出`。

使用一些方法来避免或者解决栈溢出的问题，
- 把递归调用的形式改造成其他形式，
- 使用加入定时器的方法来把当前任务拆分为其他很多小任务。

## 09 | 块级作用域：var缺陷以及为什么要引入let和const？
`正是由于 JavaScript 存在变量提升这种特性，从而导致了很多与直觉不符的代码，这也是 JavaScript 的一个重要设计缺陷。`

`探病因`——分析为什么在 JavaScript 中会存在变量提升，以及变量提升所带来的问题；
“`开药方`”——介绍如何通过`块级作用域并配合 let 和 const 关键字`来修复这种缺陷。

### 作用域（scope）
`作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。`

`全局作用域`中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。

`函数作用域`就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

在 ES6 之前，JavaScript 只支持这两种作用域，相较而言，其他语言则都普遍支持`块级作用域`。块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。

没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。

### 变量提升所带来的问题
1. 变量容易在不被察觉的情况下被覆盖掉
2. 本应销毁的变量没有被销毁

### ES6 是如何解决变量提升带来的缺陷
`ES6 引入了 let 和 const 关键字`，从而使 JavaScript 也能像其他语言一样拥有了块级作用域

### JavaScript 是如何支持块级作用域的
S6 是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？”

- 函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。
- 通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。- 在函数的作用域块内部，通过 let 声明的变量并没有被存放到词法环境中。

在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出

执行到作用域查找变量时：先着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。

### 【拓展】
var的创建和初始化被提升，赋值不会被提升。
let的创建被提升，初始化和赋值不会被提升。
function的创建、初始化和赋值均会被提升。

## 10 | 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？
### 作用域链
其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 `outer`。(例如函数的outer执行全局上下文)

函数中使用了外部变量，那么 JavaScript 引擎会去全局执行上下文中查找。我们把这个查找的链条就称为`作用域链`。

foo 函数调用的 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文？

### 词法作用域
`词法作用域就是指作用域是由代码中函数`声明`的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。`

`词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。`

### 块级作用域中的变量查找
```js

function bar() {
    var myName = "极客世界"
    let test1 = 100
    if (1) {
        let myName = "Chrome浏览器"
        console.log(test)
    }
}
function foo() {
    var myName = "极客邦"
    let test = 2
    {
        let test = 3
        bar()
    }
}
var myName = "极客时间"
let myAge = 10
let test = 1
foo()
```
首先是在 bar 函数的执行上下文中查找，但因为 bar 函数的执行上下文中没有定义 test 变量，所以根据词法作用域的规则，下一步就在 bar 函数的外部作用域中查找，也就是全局作用域。

### 闭包
```js
function foo() {
    var myName = "极客时间"
    let test1 = 1
    const test2 = 2
    var innerBar = {
        getName:function(){
            console.log(test1)
            return myName
        },
        setName:function(newName){
            myName = newName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("极客邦")
bar.getName()
console.log(bar.getName())
```

根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量，所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。
foo 函数执行完成之后，其执行上下文从栈顶弹出了，但是由于返回的 setName 和 getName 方法中使用了 foo 函数内部的变量 myName 和 test1，所以`这两个变量依然保存在内存中`。

闭包：`在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。`

### 闭包是怎么回收的
使用闭包的时候，你要尽量注意一个原则：`如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。`

### 总结
查询变量， 查找当前词法环境（没有）->查找当前变量环境（没有） -> 查找outer词法环境（没有）-> 查找outer语法环境（找到了）

## 11 | this：从JavaScript执行上下文的视角讲清楚this

`在对象内部的方法中使用对象内部的属性是一个非常普遍的需求`。但是 JavaScript 的作用域机制并不支持这一点，基于这个需求，JavaScript 又搞出来另外一套 `this 机制`。

作用域链和 this 是两套不同的系统，它们之间基本没太多联系

### JavaScript 中的 this 是什么

执行上下文（变量环境，词法环境，outer，this）
`每个执行上下文中都有一个 this`

#### 全局执行上下文中的 this
window 对象
#### 函数执行上下文中的 this
默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的

- 设置执行上下文中的 this 来指向其他对象
1. 通过函数的 call、bind 和 apply 方法设置
2. 通过对象调用方法设置
使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。
3. 通过构造函数中设置

- 当执行 new CreateObj() 的时候，JavaScript 引擎做了如下四件事：
1. 首先创建了一个空对象 tempObj；
2. 接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；
3. 然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；
4. 最后返回 tempObj 对象。

- this 的设计缺陷以及应对方案
1. 嵌套函数中的 this 不会从外层函数中继承
```js
//函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 myObj 对象
var myObj = {
  name : "极客时间", 
  showThis: function(){
    console.log(this)
    function bar(){console.log(this)}
    bar()
  }
}
myObj.showThis()
```
解决方法1：
```js
// 声明一个变量 self 用来保存 this，然后在 bar 函数中使用 self
// 这个方法的的本质是把 this 体系转换为了作用域的体系。
var myObj = {
  name : "极客时间", 
  showThis: function(){
    console.log(this)
    var self = this
    function bar(){
      self.name = "极客邦"
    }
    bar()
  }
}
myObj.showThis()
console.log(myObj.name)
console.log(window.name)
```
解决方法2：
```js
// 使用 ES6 中的箭头函数来解决这个问题
//因为 ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。
var myObj = {
  name : "极客时间", 
  showThis: function(){
    console.log(this)
    var bar = ()=>{
      this.name = "极客邦"
      console.log(this)
    }
    bar()
  }
}
myObj.showThis()
console.log(myObj.name)
console.log(window.name)
```
- 第一种是把 this 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。
- 第二种是继续使用 this，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的 this。

2. 普通函数中的 this 默认指向全局对象 window

### 总结
在使用 this 时，为了避坑，你要谨记以下三点：
1. 当函数作为对象的方法调用时，函数中的 this 就是该对象；
2. 当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；
3. 嵌套函数中的 this 不会继承外层函数的 this 值。

# V8工作原理
## 12 | 栈空间和堆空间：数据是如何存储的？
### JavaScript 是什么类型的语言
`JavaScript 是一种弱类型的、动态的语言`
`弱类型`，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。
`动态`，意味着你可以使用同一个变量保存不同类型的数据。

我们把在运行过程中需要检查数据类型的语言称为动态语言
支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言

### JavaScript 的数据类型
8种：
Boolean、null、undefined、Number、BigInt、String、Symbol、Object

第一点，使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。
第二点，Object 类型比较特殊，它是由上述 7 种类型组成的一个包含了 key-value 对的数据类型
第三点，我们把前面的 7 种数据类型称为原始类型，把最后一个对象类型称为引用类型，之所以把它们区分为两种不同的类型，是因为它们在内存中存放的位置不一样。

### 内存空间
 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是`代码空间、栈空间和堆空间`。
 #### 栈空间和堆空间
 JavaScript 引擎并不是直接将该对象存放到变量环境中，而是将它分配到堆空间里面，分配后该对象会有一个在“堆”中的地址

` 始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的`

因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率

`通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据`。引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，`堆空间很大，能存放很多大的数据`，不过缺点是分配内存和回收内存都会占用一定的时间

原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。

### 总结
JavaScript 中的 8 种数据类型，它们可以分为两大类——`原始类型和引用类型`。
原始类型的数据是存放在`栈`中，引用类型的数据是存放在`堆`中的。堆中的数据是通过引用和变量关联起来的。

## 13 | 垃圾回收：垃圾数据是如何自动回收的？
记录当前执行状态的指针（称为 ESP）
 ESP 这个指针下移操作就是销毁 当前函数执行上下文的过程（再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。）。

 ### 代际假说和分代收集
`代际假说`有以下两个特点：
- 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
- 第二个是不死的对象，会活得更久。

在 V8 中会把堆分为`新生代`和`老生代`两个区域，`新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象`。

- `副垃圾回收器，主要负责新生代的垃圾回收。`
- `主垃圾回收器，主要负责老生代的垃圾回收。`

`垃圾回收器的工作流程`:
第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。
第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。

`对象晋升策略`，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

### 总结
无论是垃圾回收的策略，还是处理全停顿的策略，往往都没有一个完美的解决方案，你需要花一些时间来做权衡，而这需要牺牲当前某几方面的指标来换取其他几个指标的提升。

## 14 | 编译器和解释器：V8是如何执行一段JavaScript代码的？
### 编译器和解释器
1. 在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。
2. 在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。

### V8 是如何执行一段 JavaScript 代码的
1. 将源代码转换为抽象语法树(AST)，并生成执行上下文

`Babel 的工作原理`就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。

2. 生成字节码
解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。

`字节码`就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。
机器码所占用的空间远远超过了字节码，所以`使用字节码可以减少系统的内存使用`。

3. 执行代码
如果有一段第一次执行的字节码，`解释器 Ignition 会逐条解释执行`
一段代码被重复执行多次，这种就称为`热点代码`，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。
`即时编译（JIT）`。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。

### JavaScript 的性能优化
对于优化 JavaScript 执行效率，你应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容：
1. 提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；
2. 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；
3. 减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。

# 浏览器中的页面循环系统
## 15 | 消息队列和事件循环：页面是怎么“活”起来的？
前面我们讲到了每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是我们今天要讲的消息队列和事件循环系统。
### 使用单线程处理安排好的任务
我们把所有任务代码按照顺序写进主线程里，等线程执行时，这些任务会按照顺序在线程中依次被执行；等所有任务执行完成之后，线程会自动退出。
#### 在线程运行过程中处理新任务
`要想在线程运行过程中，能接收并执行新的任务，就需要采用事件循环机制。`
`循环机制`，具体实现方式是在线程语句最后添加了一个 for 循环语句，线程会一直循环执行。第二点是引入了事件，可
`引入事件`，可以在线程运行过程中，等待用户输入的数字，等待过程中线程处于暂停状态，一旦接收到用户输入的信息，那么线程会被激活，然后执行相加运算，最后输出结果。

#### 处理其他线程发送过来的任务--消息队列
`消息队列是一种数据结构，可以存放要执行的任务`。它符合队列“`先进先出`”的特点，也就是说`要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。`

`渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息`，接收到消息之后，会将这些消息组装成任务发送给渲染主线程。

#### 消息队列中的任务类型
如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。
除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。
以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。

#### 如何安全退出
当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？Chrome 是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。
#### 页面使用单线程的缺点
- 第一个问题是如何处理高优先级的任务。(微任务)
如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的`执行效率`；如果采用异步方式，又会影响到`监控的实时性`。
通常我们把消息队列中的任务称为`宏任务`，每个宏任务中都包含了一个`微任务队列`，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。
- 第二个是如何解决单个任务执行时长过久的问题。
JavaScript 可以通过回调功能来规避这种问题

### 实践：浏览器页面是如何运行的
你可以打开开发者工具，点击“Performance”标签，选择左上角的“start porfiling and load page”来记录整个页面加载过程中的事件执行情况

### 总结
浏览器页面是由消息队列和事件循环系统来驱动的。
- 如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。
- 要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。
- 如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。
- 如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。
- 消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务。

每个宏任务都有一个微任务列表，在宏任务的执行过程中产生微任务会被添加到改列表中，等宏任务快执行结束之后，会执行微认为列表，所以微任务依然运行在当前宏任务的执行环境中，这个特性会导致宏任务和微任务有一些本质上的区别

## 16 | WebAPI：setTimeout是如何实现的？
典型的事件
- 当接收到 HTML 文档数据，渲染引擎就会将“解析 DOM”事件添加到消息队列中，
- 当用户改变了 Web 页面的窗口大小，渲染引擎就会将“重新布局”的事件添加到消息队列中。
- 当触发了 JavaScript 引擎垃圾回收机制，渲染引擎会将“垃圾回收”任务添加到消息队列中。
- 同样，如果要执行一段异步 JavaScript 代码，也是需要将执行任务添加到消息队列中。

在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了`需要延迟执行的任务列表`，包括了定时器和 Chromium 内部一些需要延迟执行的任务。

消息循环系统是怎么触发延迟队列的?
处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。通过这样的方式，一个完整的定时器就实现了。

### 使用 setTimeout 的一些注意事项
1. 如果当前任务执行时间过久，会影响定时器任务的执
2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒
3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒
4. 延时执行时间有最大值
Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行
5. 使用 setTimeout 设置的回调函数中的 this 不符合直觉（可以使用bind，箭头函数）
如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。

### 总结
- 首先，为了支持定时器的实现，浏览器增加了延时队列。
- 其次，由于消息队列排队和一些系统级别的限制，通过 setTimeout 设置的回调任务并非总是可以实时地被执行，这样就不能满足一些实时性要求较高的需求了。
- 最后，在定时器中使用过程中，还存在一些陷阱，需要多加注意。

### requestAnimationFrame和setTimeout的比较
requestAnimationFrame 提供一个原生的API去执行动画的效果，它会在一帧（一般是16ms）间隔内根据选择浏览器情况去执行相关动作。
setTimeout是在特定的时间间隔去执行任务，不到时间间隔不会去执行，这样浏览器就没有办法去自动优化。

浏览器的页面是通过消息队列和事件循环系统来驱动的。settimeout的函数会被加入到延迟消息队列中，
等到执行完Task任务之后就会执行延迟队列中的任务。然后分析几种场景下面的setimeout的执行方式。
1. 如果执行一个很耗时的任务，会影响延迟消息队列中任务的执行
2. 存在嵌套带调用时候，系统会设置最短时间间隔为4s（超过5层）
3. 未激活的页面，setTimeout最小时间间隔为1000ms
4. 延时执行时间的最大值2147483647，溢出会导致定时器立即执行
5. setTimeout设置回调函数this会是回调时候对应的this对象，可以使用箭头函数解决

## 17 | WebAPI：XMLHttpRequest是怎么实现的？

### 回调函数 VS 系统调用栈
将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是`回调函数`

```js
let callback = function(){
    console.log('i am do homework')
}
function doWork(cb) {
    console.log('start do work')
    cb()
    console.log('end do work')
}
doWork(callback)
```
回调函数 callback 是在主函数 doWork 返回之前执行的，我们把这个回调过程称为`同步回调`。

```js
let callback = function(){
    console.log('i am do homework')
}
function doWork(cb) {
    console.log('start do work')
    setTimeout(cb,1000)   
    console.log('end do work')
}
doWork(callback)
```
我们使用了 setTimeout 函数让 callback 在 doWork 函数执行结束后，又延时了 1 秒再执行，这次 callback 并没有在主函数 doWork 内部被调用，我们把这种回调函数在主函数外部执行的过程称为`异步回调`。

当循环系统在执行一个任务的时候，都要为这个任务维护一个`系统调用栈`。这个系统调用栈类似于 JavaScript 的调用栈，只不过系统调用栈是 Chromium 的开发语言 C++ 来维护的，其完整的调用栈信息你可以通过 chrome://tracing/ 来抓取。当然，你也可以通过 Performance 来抓取它核心的调用信息

异步回调过程，异步回调是指回调函数在主函数之外执行，一般有两种方式：
- 第一种是把异步函数做成一个任务，添加到信息队列尾部；
- 第二种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执行微任务了。

### XMLHttpRequest 运作机制
第一步：创建 XMLHttpRequest 对象。
第二步：为 xhr 对象注册回调函数。
第三步：配置基础的请求信息。
第四步：发起请求。
### XMLHttpRequest 使用过程中的“坑”
1. 跨域问题
2. HTTPS 混合内容的问题

fetch采用了promise来封装，在使用方式上更强现代化，同时还原生支持async/await。在chromium中，fetch是完全重新实现的，和xmlhttprequest没有什么关系！
在项目中推荐使用fetch