# 开篇
- 如果你要开发流畅的页面，或者诊断 Web 页面中的性能问题，那你就需要了解 `URL 是怎么变成页面的`，只有弄懂这些之后，你才可以站在全局的角度定位问题或者写出高效的代码。
- 可以把`浏览器`看成一个黑盒，左边输入一个 URL，经过黑盒处理之后，右边返回你预期的效果
- `首屏的显示`就涉及了 DNS、HTTP、DOM 解析、CSS 阻塞、JavaScript 阻塞等技术因素，其中一项没处理好就可能导致整个页面的延时。
# 宏观视角下的浏览器
## 01 | Chrome架构：仅仅打开了1个页面，为什么有4个进程？
- 想要设计高性能 Web 应用，还是要优化现有的 Web 应用，需要了解浏览器中的`网络流程`、`页面渲染过程`，`JavaScript 执行流程`，以及 `Web 安全理论`。
### 并行处理
- 单线程：按顺序执行任务
- 多线程（并行处理）：同一时刻处理多个任务
# 进程
- `线程是不能单独存在的，它是由进程来启动和管理的`
- `一个进程就是一个程序的运行实例`。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫`进程`。
### 进程和线程
- 1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。
- 2. 线程之间共享进程中的数据。
- 3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。（当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。）
- 4. 进程之间的内容相互隔离。

- 如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信（IPC）的机制了。

### 单进程浏览器时代
- `指浏览器的所有功能模块都是运行在同一个进程里`，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。
- 用浏览器打开多个页面时，突然某个页面崩溃了或者失去响应，随之而来的是整个浏览器的崩溃或者无响应
### 多进程浏览器时代
- 优点：多进程模型提升了浏览器的稳定性、流畅性和安全性。
- `更高的资源占用`。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。
- `更复杂的体系架构`。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。
### 未来面向服务的架构
- 在 2016 年，Chrome 官方团队使用“`面向服务的架构`”（Services Oriented Architecture，简称 `SOA`）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，`访问服务（Service）必须使用定义好的接口`，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。

## 02 | TCP协议：如何保证页面文件能被完整送达浏览器？
- 在衡量 Web 页面性能的时候有一个重要的指标叫“`FP（First Paint）`”，是`指从页面加载到首次开始绘制的时长`。
- 影响 FP 指标：其中一个重要的因素是`网络加载速度`。
### 一个数据包的“旅程”
- `互联网，实际上是一套理念和协议组成的体系架构。`其中，协议是一套众所周知的规则和标准，如果各方都同意使用，那么它们之间的通信将变得毫无障碍。
#### 1. IP：把数据包送达目的主机
- `网际协议（Internet Protocol，简称 IP）`
- `计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。`
- `IP 头是` IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息
#### 2. UDP：把数据包送达应用程序
- IP只负责将数据包传到对方电脑，而交给那个程序，需要需要基于 IP 之上开发能和应用打交道的协议，最常见的是“`用户数据包协议`（User Datagram Protocol）”，简称 `UDP`。
- IP 通过 IP 地址信息把数据包发送给指定的电脑，而 `UDP 通过``端口号``把数据包分发给正确的程序`
- `UDP 头`中除了目的端口，还有源端口号等信息
- `UDP 不能保证数据可靠性`，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。
#### 3. TCP：把数据完整地送达应用程序
对于浏览器请求，或者邮件这类要求数据传输可靠性（reliability）的应用，如果使用 UDP 来传输会存在两个问题：
- 数据包在传输过程中容易丢失；
- 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。

- `TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。`相对于 UDP，TCP 有下面两个特点:
- 对于数据包丢失的情况，TCP 提供重传机制；
- TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

`TCP 头`除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包

一个完整的 TCP 连接的生命周期包括了“`建立连接`”“`传输数据`”和“`断开连接`”三个阶段。

- `建立连接阶段`。这个阶段是通过“`三次握手`”来建立客户端和服务器之间的连接。
`三次握手`，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。
- `传输数据阶段`。在该阶段，`接收端需要对每个数据包进行确认操作`，也就是接收端在接收到数据包之后，需要发送确认数据包给发送端。所以当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为`数据包丢失`，并触发发送端的`重发机制`。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会`按照 TCP 头中的序号为其排序`，从而保证组成`完整的数据`。
- `断开连接阶段`。“四次挥手”来保证双方都能断开连接。

`TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度`，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。

## 03 | HTTP请求流程：为什么很多站点第二次打开速度会很快？
- HTTP 协议，正是建立在 TCP 连接基础之上的。`HTTP 是一种允许浏览器向服务器获取资源的协议，是 Web 的基础`，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。此外，`HTTP 也是浏览器使用最广的协议`。
- `DNS 缓存`和`页面资源缓存`这两块数据是会被浏览器缓存的。其中，DNS 缓存比较简单，它主要就是在浏览器本地把对应的 IP 和域名关联起来.
- `浏览器缓存数据`:当服务器返回 `HTTP 响应头`给浏览器时，浏览器是`通过响应头中的 Cache-Control 字段来设置是否缓存该资源`。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比如上图设置的缓存过期时间是 2000 秒。
- 服务器收到请求头后，会根据 `If-None-Match`(If-None-Match:"4f80f-13c-3a1xb12a")的值来判断请求的资源是否有更新。如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”如果资源有更新，服务器就直接返回最新资源给浏览器。


### 浏览器端发起HTTP请求流程
#### 1.构建请求
浏览器构建`请求行`信息
```js
GET /index.html HTTP1.1
```
#### 2.查找缓存
- 在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件
- `浏览器缓存是一种在本地保存资源副本，以供下次请求时直接使用的技术。`

#### 3. 准备 IP 地址和端口
- 浏览器使用 `HTTP 协议作为应用层协议`，用来封装请求的文本信息；并使用 `TCP/IP 作传输层协议`将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。也就是说 `HTTP 的内容是通过 TCP 的传输数据阶段来实现的`。
- 极客时间网站的 IP 是 39.106.233.176,  难以记忆，但使用极客时间的域名（time.geekbang.org）就好记多了，所以基于这个需求又出现了一个服务,负责把域名和 IP 地址做一一映射关系。这套域名映射为 IP 的系统就叫做“`域名系统`”，简称 `DNS`（Domain Name System）。
- 第一步浏览器会请求 DNS 返回域名对应的 IP
- 浏览器还提供了 `DNS 数据缓存服务`
- 拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。

#### 4. 等待 TCP 队列
Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。
#### 5. 建立 TCP 连接
#### 6. 发送 HTTP 请求
一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。

- 首先浏览器会向服务器发送`请求行`，它包括了`请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。`
### 服务器端处理 HTTP 请求流程
#### 1. 返回请求
可以通过工具软件 curl 来查看返回请求数据，`curl -i https://time.geekbang.org/`(-i是为了返回响应行、响应头和响应体的数据；-I表示只需要获取响应头和响应行数据，而不需要获取响应体的数据)
服务器也会随同响应向浏览器发送`响应头`。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。
发送完响应头后，服务器就可以继续发送`响应体`的数据，通常，响应体就包含了 HTML 的实际内容。
#### 2. 断开连接
通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：`Connection:Keep-Alive`。
那么 TCP 连接在发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。`保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度`。比如，一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，你就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。

#### 3. 重定向
响应行返回的状态码是 301，状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。

## 04 | 导航流程：从输入URL到页面展示，这中间发生了什么？
- `浏览器进程`主要负责用户交互、子进程管理和文件储存等功能。
- `网络进程`是面向渲染进程和浏览器进程等提供网络下载功能。
- `渲染进程`的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的。这也是为什么 Chrome 会让渲染进程运行在安全沙箱里，就是为了保证系统的安全。

- 首先，浏览器进程接收到用户输入的 URL 请求，浏览器进程便将该 URL 转发给网络进程。
- 然后，在网络进程中发起真正的 URL 请求。
- 接着网络进程接收到了响应头数据，便解析响应头数据，并将数据转发给浏览器进程。
- 浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程；
- 渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道；
- 最后渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了”。
- 浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态。
这其中，`用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。`

## 05 | 渲染流程（上）：HTML、CSS和JavaScript，是如何变成页面的？
- `HTML 的内容是由标记和文本组成`。标记也称为`标签`
- CSS 又称为`层叠样式表，是由选择器和属性组成`
- `JavaScript（简称为 JS），使用它可以使网页的内容“动”起来`
- 按照渲染的时间顺序，流水线可分为如下几个`子阶段`：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。
开始每个子阶段都有其`输入的内容`；然后每个子阶段有其`处理过程`；最终每个子阶段会生成`输出内容`。

在 HTML 页面内容被提交给渲染引擎之后，渲染引擎首先将 HTML 解析为浏览器可以理解的 DOM；然后根据 CSS 样式表，计算出 DOM 树所有节点的样式；接着又计算每个元素的几何坐标位置，并将这些信息保存在布局树中。

### 构建 DOM 树
- `因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。`
构建 DOM 树的`输入内容`是一个非常简单的 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。
### 样式计算（Recalculate Style）
#### 1. 把 CSS 转换为浏览器能够理解的结构
浏览器也是无法直接理解这些纯文本的 CSS 样式，所以`当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。`该结构同时具备了查询和修改功能，这会为后面的样式操作提供基础。
#### 2. 转换样式表中的属性值，使其标准化
CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以`需要将所有值转换为渲染引擎容易理解的、标准化的计算值`，这个过程就是属性值标准化。
#### 3. 计算出 DOM 树中每个节点的具体样式
`这就涉及到 CSS 的继承规则和层叠规则了。`
`CSS 继承`就是每个 DOM 节点都包含有父节点的样式
`层叠`是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。

如果你想了解每个 DOM 元素最终的计算样式，可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，然后再选择“Computed”子标签

### 布局阶段
`接下来就需要计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。`

Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。

#### 1. 创建布局树
你可能注意到了 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以`在显示之前，我们还要额外地构建一棵只包含可见元素布局树`
#### 2. 布局计算
现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了

## 06 | 渲染流程（下）：HTML、CSS和JavaScript，是如何变成页面的？
### 分层
因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了更加方便地实现这些效果，`渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树`（LayerTree）。如果你熟悉 PS，相信你会很容易理解图层的概念，正是这些图层叠加在一起构成了最终的页面图像。

`浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面`

通常情况下，`并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层`

通常满足下面两点中任意一点的元素就渲染引擎可以被提升为单独的一个图层。
- `第一点，拥有层叠上下文属性的元素会被提升为单独的一层。`
从图中可以看出，明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。
- `第二点，需要剪裁（clip）的地方也会被创建为图层。`
出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。

### 图层绘制
渲染引擎实现图层的绘制与之类似，会把一个图层的绘制拆分成很多小的`绘制指令`，然后再把这些指令按照顺序组成一个待绘制列表

### 栅格化（raster）操作
当图层的绘制列表准备好之后，主线程会把该绘制列表`提交`（commit）给合成线程
通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做`视口`（viewport）。
`合成线程会将图层划分为图块`（tile），这些图块的大小通常是 256x256 或者 512x512，然后`合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。`
### 合成和显示
一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

### 渲染流水线大总结
1. 渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
2. 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
3. 创建布局树，并计算元素的布局信息。
4. 对布局树进行分层，并生成分层树。
5. 为每个图层生成绘制列表，并将其提交到合成线程。
6. 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
7. 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
8. 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

### “重排”“重绘”和“合成”
#### 1. `更新了元素的几何属性（重排）`
如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，`重排需要更新完整的渲染流水线，所以开销也是最大的`。

#### 2. 更新元素的绘制属性（重绘）
如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，`重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。`
#### 3. 直接合成阶段
那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做`合成`。

减少重排重绘方法：
1. 使用 class 操作样式，而不是频繁操作 style
2. 避免使用 table 布局
3. 批量dom 操作，例如 createDocumentFragment，或者使用框架，例如 React
4. Debounce window resize 事件
5. 对 dom 属性的读写要分离
6. will-change: transform 做优化


# 浏览器中的JavaScript执行机制

## 07 | 变量提升：JavaScript代码是按顺序执行的吗？

### 变量提升（Hoisting）
所谓的变量提升，`是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分(var...)和函数的声明部分(function)提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。`
`函数和变量在执行之前都提升到了代码开头。`

### JavaScript 代码的执行流程
`实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中`
JavaScript 代码->`编译`->`执行`阶段。

#### 1. 编译阶段
`第一部分：变量提升部分的代码。`
`第二部分：执行部分的代码。`

输入一段代码，经过编译后，会生成两部分内容：`执行上下文（Execution context）和可执行代码。`
`执行上下文是 JavaScript 执行一段代码时的运行环境`，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等

在执行上下文中存在一个`变量环境的对象`（Viriable Environment），该对象中保存了变量提升的内容

#### 2. 执行阶段

#### 代码中出现相同的变量或者函数怎么办？
一段代码如果定义了两个相同名字的函数，那么最终生效的是最后一个函数。

下面是关于同名变量和函数的两点处理原则：

- 1:如果是同名的函数，JavaScript编译阶段会选择最后声明的那个。

- 2:如果变量和函数同名，那么在编译阶段，变量的声明会被忽略

## 08 | 调用栈：为什么JavaScript代码会出现栈溢出？
`调用栈``就是用来管理函数调用关系的一种数据结构`。因此要讲清楚调用栈，你还要先弄明白`函数调用`和`栈结构`。什么是函数调用

### 什么是函数调用
函数调用就是运行一个函数，具体使用方式是使用函数名称跟着一对小括号

JavaScript 引擎是如何管理这些执行上下文的呢？`通过一种叫栈的数据结构来管理的`

### 什么是栈
栈中的元素满足`后进先出`的特点

### 什么是 JavaScript 的调用栈
把这种用来管理执行上下文的栈称为`执行上下文栈`，又称`调用栈`。

在代码的执行过程中，调用栈的状态变化情况
1. 创建全局上下文，并将其压入栈底
2. 调用函数时，，JavaScript 引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中
3. 函数调用完毕，调用函数的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了

`调用栈是 JavaScript 引擎追踪函数执行的一个机制`，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。

### 在开发中，如何利用好调用栈
#### 1. 如何利用浏览器查看调用栈的信息
- 打断点的时候，面板中的“call stack”,显示出来了函数的调用关系：栈的最底部是 anonymous，也就是全局的函数入口；中间是 addAll 函数；顶部是 add 函数。这就清晰地反映了函数的调用关系，所以`在分析复杂结构代码，或者检查 Bug 时，调用栈都是非常有用的。`
- console.trace() 来输出当前的函数调用关系

#### 2. 栈溢出（Stack Overflow）
`调用栈是有大小的`，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做`栈溢出`。

使用一些方法来避免或者解决栈溢出的问题，
- 把递归调用的形式改造成其他形式，
- 使用加入定时器的方法来把当前任务拆分为其他很多小任务。

## 09 | 块级作用域：var缺陷以及为什么要引入let和const？
`正是由于 JavaScript 存在变量提升这种特性，从而导致了很多与直觉不符的代码，这也是 JavaScript 的一个重要设计缺陷。`

`探病因`——分析为什么在 JavaScript 中会存在变量提升，以及变量提升所带来的问题；
“`开药方`”——介绍如何通过`块级作用域并配合 let 和 const 关键字`来修复这种缺陷。

### 作用域（scope）
`作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。`

`全局作用域`中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。

`函数作用域`就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。

在 ES6 之前，JavaScript 只支持这两种作用域，相较而言，其他语言则都普遍支持`块级作用域`。块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。

没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。

### 变量提升所带来的问题
1. 变量容易在不被察觉的情况下被覆盖掉
2. 本应销毁的变量没有被销毁

### ES6 是如何解决变量提升带来的缺陷
`ES6 引入了 let 和 const 关键字`，从而使 JavaScript 也能像其他语言一样拥有了块级作用域

### JavaScript 是如何支持块级作用域的
S6 是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？”

- 函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。
- 通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。- 在函数的作用域块内部，通过 let 声明的变量并没有被存放到词法环境中。

在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出

执行到作用域查找变量时：先着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。

### 【拓展】
var的创建和初始化被提升，赋值不会被提升。
let的创建被提升，初始化和赋值不会被提升。
function的创建、初始化和赋值均会被提升。

## 10 | 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？
### 作用域链
其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 `outer`。(例如函数的outer执行全局上下文)

函数中使用了外部变量，那么 JavaScript 引擎会去全局执行上下文中查找。我们把这个查找的链条就称为`作用域链`。

foo 函数调用的 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文？

### 词法作用域
`词法作用域就是指作用域是由代码中函数`声明`的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。`

`词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。`

### 块级作用域中的变量查找
```js

function bar() {
    var myName = "极客世界"
    let test1 = 100
    if (1) {
        let myName = "Chrome浏览器"
        console.log(test)
    }
}
function foo() {
    var myName = "极客邦"
    let test = 2
    {
        let test = 3
        bar()
    }
}
var myName = "极客时间"
let myAge = 10
let test = 1
foo()
```
首先是在 bar 函数的执行上下文中查找，但因为 bar 函数的执行上下文中没有定义 test 变量，所以根据词法作用域的规则，下一步就在 bar 函数的外部作用域中查找，也就是全局作用域。

### 闭包
```js
function foo() {
    var myName = "极客时间"
    let test1 = 1
    const test2 = 2
    var innerBar = {
        getName:function(){
            console.log(test1)
            return myName
        },
        setName:function(newName){
            myName = newName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("极客邦")
bar.getName()
console.log(bar.getName())
```

根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量，所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。
foo 函数执行完成之后，其执行上下文从栈顶弹出了，但是由于返回的 setName 和 getName 方法中使用了 foo 函数内部的变量 myName 和 test1，所以`这两个变量依然保存在内存中`。

闭包：`在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。`

### 闭包是怎么回收的
使用闭包的时候，你要尽量注意一个原则：`如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。`

### 总结
查询变量， 查找当前词法环境（没有）->查找当前变量环境（没有） -> 查找outer词法环境（没有）-> 查找outer语法环境（找到了）

## 11 | this：从JavaScript执行上下文的视角讲清楚this

`在对象内部的方法中使用对象内部的属性是一个非常普遍的需求`。但是 JavaScript 的作用域机制并不支持这一点，基于这个需求，JavaScript 又搞出来另外一套 `this 机制`。

作用域链和 this 是两套不同的系统，它们之间基本没太多联系

### JavaScript 中的 this 是什么

执行上下文（变量环境，词法环境，outer，this）
`每个执行上下文中都有一个 this`

#### 全局执行上下文中的 this
window 对象
#### 函数执行上下文中的 this
默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的

- 设置执行上下文中的 this 来指向其他对象
1. 通过函数的 call、bind 和 apply 方法设置
2. 通过对象调用方法设置
使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。
3. 通过构造函数中设置

- 当执行 new CreateObj() 的时候，JavaScript 引擎做了如下四件事：
1. 首先创建了一个空对象 tempObj；
2. 接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；
3. 然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；
4. 最后返回 tempObj 对象。

- this 的设计缺陷以及应对方案
1. 嵌套函数中的 this 不会从外层函数中继承
```js
//函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 myObj 对象
var myObj = {
  name : "极客时间", 
  showThis: function(){
    console.log(this)
    function bar(){console.log(this)}
    bar()
  }
}
myObj.showThis()
```
解决方法1：
```js
// 声明一个变量 self 用来保存 this，然后在 bar 函数中使用 self
// 这个方法的的本质是把 this 体系转换为了作用域的体系。
var myObj = {
  name : "极客时间", 
  showThis: function(){
    console.log(this)
    var self = this
    function bar(){
      self.name = "极客邦"
    }
    bar()
  }
}
myObj.showThis()
console.log(myObj.name)
console.log(window.name)
```
解决方法2：
```js
// 使用 ES6 中的箭头函数来解决这个问题
//因为 ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。
var myObj = {
  name : "极客时间", 
  showThis: function(){
    console.log(this)
    var bar = ()=>{
      this.name = "极客邦"
      console.log(this)
    }
    bar()
  }
}
myObj.showThis()
console.log(myObj.name)
console.log(window.name)
```
- 第一种是把 this 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。
- 第二种是继续使用 this，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的 this。

2. 普通函数中的 this 默认指向全局对象 window

### 总结
在使用 this 时，为了避坑，你要谨记以下三点：
1. 当函数作为对象的方法调用时，函数中的 this 就是该对象；
2. 当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；
3. 嵌套函数中的 this 不会继承外层函数的 this 值。

# V8工作原理
## 12 | 栈空间和堆空间：数据是如何存储的？
### JavaScript 是什么类型的语言
`JavaScript 是一种弱类型的、动态的语言`
`弱类型`，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。
`动态`，意味着你可以使用同一个变量保存不同类型的数据。

我们把在运行过程中需要检查数据类型的语言称为动态语言
支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言

### JavaScript 的数据类型
8种：
Boolean、null、undefined、Number、BigInt、String、Symbol、Object

第一点，使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。
第二点，Object 类型比较特殊，它是由上述 7 种类型组成的一个包含了 key-value 对的数据类型
第三点，我们把前面的 7 种数据类型称为原始类型，把最后一个对象类型称为引用类型，之所以把它们区分为两种不同的类型，是因为它们在内存中存放的位置不一样。

### 内存空间
 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是`代码空间、栈空间和堆空间`。
 #### 栈空间和堆空间
 JavaScript 引擎并不是直接将该对象存放到变量环境中，而是将它分配到堆空间里面，分配后该对象会有一个在“堆”中的地址

` 始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的`

因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率

`通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据`。引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，`堆空间很大，能存放很多大的数据`，不过缺点是分配内存和回收内存都会占用一定的时间

原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。

### 总结
JavaScript 中的 8 种数据类型，它们可以分为两大类——`原始类型和引用类型`。
原始类型的数据是存放在`栈`中，引用类型的数据是存放在`堆`中的。堆中的数据是通过引用和变量关联起来的。

## 13 | 垃圾回收：垃圾数据是如何自动回收的？
记录当前执行状态的指针（称为 ESP）
 ESP 这个指针下移操作就是销毁 当前函数执行上下文的过程（再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。）。

 ### 代际假说和分代收集
`代际假说`有以下两个特点：
- 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
- 第二个是不死的对象，会活得更久。

在 V8 中会把堆分为`新生代`和`老生代`两个区域，`新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象`。

- `副垃圾回收器，主要负责新生代的垃圾回收。`
- `主垃圾回收器，主要负责老生代的垃圾回收。`

`垃圾回收器的工作流程`:
第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。
第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。
第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。

`对象晋升策略`，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

### 总结
无论是垃圾回收的策略，还是处理全停顿的策略，往往都没有一个完美的解决方案，你需要花一些时间来做权衡，而这需要牺牲当前某几方面的指标来换取其他几个指标的提升。

## 14 | 编译器和解释器：V8是如何执行一段JavaScript代码的？
### 编译器和解释器
1. 在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。
2. 在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。

### V8 是如何执行一段 JavaScript 代码的
1. 将源代码转换为抽象语法树(AST)，并生成执行上下文

`Babel 的工作原理`就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。

2. 生成字节码
解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。

`字节码`就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。
机器码所占用的空间远远超过了字节码，所以`使用字节码可以减少系统的内存使用`。

3. 执行代码
如果有一段第一次执行的字节码，`解释器 Ignition 会逐条解释执行`
一段代码被重复执行多次，这种就称为`热点代码`，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。
`即时编译（JIT）`。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。

### JavaScript 的性能优化
对于优化 JavaScript 执行效率，你应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容：
1. 提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；
2. 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；
3. 减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。

# 浏览器中的页面循环系统
## 15 | 消息队列和事件循环：页面是怎么“活”起来的？
前面我们讲到了每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是我们今天要讲的消息队列和事件循环系统。
### 使用单线程处理安排好的任务
我们把所有任务代码按照顺序写进主线程里，等线程执行时，这些任务会按照顺序在线程中依次被执行；等所有任务执行完成之后，线程会自动退出。
#### 在线程运行过程中处理新任务
`要想在线程运行过程中，能接收并执行新的任务，就需要采用事件循环机制。`
`循环机制`，具体实现方式是在线程语句最后添加了一个 for 循环语句，线程会一直循环执行。第二点是引入了事件，可
`引入事件`，可以在线程运行过程中，等待用户输入的数字，等待过程中线程处于暂停状态，一旦接收到用户输入的信息，那么线程会被激活，然后执行相加运算，最后输出结果。

#### 处理其他线程发送过来的任务--消息队列
`消息队列是一种数据结构，可以存放要执行的任务`。它符合队列“`先进先出`”的特点，也就是说`要添加任务的话，添加到队列的尾部；要取出任务的话，从队列头部去取。`

`渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息`，接收到消息之后，会将这些消息组装成任务发送给渲染主线程。

#### 消息队列中的任务类型
如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。
除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。
以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。

#### 如何安全退出
当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？Chrome 是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。
#### 页面使用单线程的缺点
- 第一个问题是如何处理高优先级的任务。(微任务)
如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的`执行效率`；如果采用异步方式，又会影响到`监控的实时性`。
通常我们把消息队列中的任务称为`宏任务`，每个宏任务中都包含了一个`微任务队列`，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。
- 第二个是如何解决单个任务执行时长过久的问题。
JavaScript 可以通过回调功能来规避这种问题

### 实践：浏览器页面是如何运行的
你可以打开开发者工具，点击“Performance”标签，选择左上角的“start porfiling and load page”来记录整个页面加载过程中的事件执行情况

### 总结
浏览器页面是由消息队列和事件循环系统来驱动的。
- 如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。
- 要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。
- 如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。
- 如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。
- 消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务。

每个宏任务都有一个微任务列表，在宏任务的执行过程中产生微任务会被添加到改列表中，等宏任务快执行结束之后，会执行微认为列表，所以微任务依然运行在当前宏任务的执行环境中，这个特性会导致宏任务和微任务有一些本质上的区别

## 16 | WebAPI：setTimeout是如何实现的？
典型的事件
- 当接收到 HTML 文档数据，渲染引擎就会将“解析 DOM”事件添加到消息队列中，
- 当用户改变了 Web 页面的窗口大小，渲染引擎就会将“重新布局”的事件添加到消息队列中。
- 当触发了 JavaScript 引擎垃圾回收机制，渲染引擎会将“垃圾回收”任务添加到消息队列中。
- 同样，如果要执行一段异步 JavaScript 代码，也是需要将执行任务添加到消息队列中。

在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了`需要延迟执行的任务列表`，包括了定时器和 Chromium 内部一些需要延迟执行的任务。

消息循环系统是怎么触发延迟队列的?
处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。通过这样的方式，一个完整的定时器就实现了。

### 使用 setTimeout 的一些注意事项
1. 如果当前任务执行时间过久，会影响定时器任务的执
2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒
3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒
4. 延时执行时间有最大值
Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行
5. 使用 setTimeout 设置的回调函数中的 this 不符合直觉（可以使用bind，箭头函数）
如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。

### 总结
- 首先，为了支持定时器的实现，浏览器增加了延时队列。
- 其次，由于消息队列排队和一些系统级别的限制，通过 setTimeout 设置的回调任务并非总是可以实时地被执行，这样就不能满足一些实时性要求较高的需求了。
- 最后，在定时器中使用过程中，还存在一些陷阱，需要多加注意。

### requestAnimationFrame和setTimeout的比较
requestAnimationFrame 提供一个原生的API去执行动画的效果，它会在一帧（一般是16ms）间隔内根据选择浏览器情况去执行相关动作。
setTimeout是在特定的时间间隔去执行任务，不到时间间隔不会去执行，这样浏览器就没有办法去自动优化。

浏览器的页面是通过消息队列和事件循环系统来驱动的。settimeout的函数会被加入到延迟消息队列中，
等到执行完Task任务之后就会执行延迟队列中的任务。然后分析几种场景下面的setimeout的执行方式。
1. 如果执行一个很耗时的任务，会影响延迟消息队列中任务的执行
2. 存在嵌套带调用时候，系统会设置最短时间间隔为4s（超过5层）
3. 未激活的页面，setTimeout最小时间间隔为1000ms
4. 延时执行时间的最大值2147483647，溢出会导致定时器立即执行
5. setTimeout设置回调函数this会是回调时候对应的this对象，可以使用箭头函数解决

## 17 | WebAPI：XMLHttpRequest是怎么实现的？

### 回调函数 VS 系统调用栈
将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是`回调函数`

```js
let callback = function(){
    console.log('i am do homework')
}
function doWork(cb) {
    console.log('start do work')
    cb()
    console.log('end do work')
}
doWork(callback)
```
回调函数 callback 是在主函数 doWork 返回之前执行的，我们把这个回调过程称为`同步回调`。

```js
let callback = function(){
    console.log('i am do homework')
}
function doWork(cb) {
    console.log('start do work')
    setTimeout(cb,1000)   
    console.log('end do work')
}
doWork(callback)
```
我们使用了 setTimeout 函数让 callback 在 doWork 函数执行结束后，又延时了 1 秒再执行，这次 callback 并没有在主函数 doWork 内部被调用，我们把这种回调函数在主函数外部执行的过程称为`异步回调`。

当循环系统在执行一个任务的时候，都要为这个任务维护一个`系统调用栈`。这个系统调用栈类似于 JavaScript 的调用栈，只不过系统调用栈是 Chromium 的开发语言 C++ 来维护的，其完整的调用栈信息你可以通过 chrome://tracing/ 来抓取。当然，你也可以通过 Performance 来抓取它核心的调用信息

异步回调过程，异步回调是指回调函数在主函数之外执行，一般有两种方式：
- 第一种是把异步函数做成一个任务，添加到信息队列尾部；
- 第二种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执行微任务了。

### XMLHttpRequest 运作机制
第一步：创建 XMLHttpRequest 对象。
第二步：为 xhr 对象注册回调函数。
第三步：配置基础的请求信息。
第四步：发起请求。
### XMLHttpRequest 使用过程中的“坑”
1. 跨域问题
2. HTTPS 混合内容的问题

fetch采用了promise来封装，在使用方式上更强现代化，同时还原生支持async/await。在chromium中，fetch是完全重新实现的，和xmlhttprequest没有什么关系！
在项目中推荐使用fetch

## 18 | 宏任务和微任务：不是所有任务都是一个待遇

`微任务`可以在实时性和效率之间做一个有效的权衡。

### 宏任务
这些消息队列中的任务称为`宏任务`。
宏任务难以满足对时间精度要求较高的任务
JavaScript 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间。

`setTimeout 函数触发的回调函数都是宏任务`

### 微任务

异步回调
- 第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。 setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的
- 第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。

`微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。`

当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个`微任务队列`
这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。
个宏任务都关联了一个微任务队列。

产生微任务有两种方式
- 第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。
- 第二种方式是使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。

微任务队列是何时被执行的
通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。`WHATWG 把执行微任务的时间点称为检查点`。
如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在`执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行`，而是在当前的宏任务中继续执行。

- 微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。
- 微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。
- 在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。

### 监听 DOM 变化方法演变
 2000 年的时候引入了 Mutation Event，Mutation Event 采用了`观察者的设计模式`，当 DOM 有变动时就会立刻触发相应的事件，这种方式属于同步回调
 从 DOM4 开始，推荐使用 MutationObserver 来代替 Mutation Event。MutationObserver API 可以用来监视 DOM 的变化，包括属性的变化、节点的增减、内容的变化等。

 相比较 Mutation Event，MutationObserver 到底做了哪些改进呢？
 首先，MutationObserver 将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。这样即使频繁地操纵 DOM，也不会对性能造成太大的影响。
MutationObserver 采用了“`异步 + 微任务`”的策略。
- 通过`异步`操作解决了同步操作的`性能问题`；
- 通过`微任务`解决了`实时性的问题`。

## 19 | Promise：使用Promise，告别回调函数

嵌套了太多的回调函数就很容易使得自己陷入了`回调地狱`

### Promise：消灭嵌套调用和多次错误处理
`Promise 实现了回调函数的延时绑定`
因为 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被 onReject 函数处理或 catch 语句捕获为止。具备了这样“冒泡”的特性后，就不需要在每个 Promise 对象中单独捕获异常了

## 20 | async/await：使用同步的方式去写异步代码

`ES7 引入了 async/await，这是 JavaScript 异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰`

### 生成器 VS 协程
`生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的`

```js
// 函数 genDemo 并不是一次执行完的，全局代码和 genDemo 函数交替执行。其实这就是生成器函数的特性，可以暂停执行，也可以恢复执行
function* genDemo() {
    console.log("开始执行第一段")
    yield 'generator 2'

    console.log("开始执行第二段")
    yield 'generator 2'

    console.log("开始执行第三段")
    yield 'generator 2'

    console.log("执行结束")
    return 'generator 2'
}

console.log('main 0')
let gen = genDemo()
console.log(gen.next().value)
console.log('main 1')
console.log(gen.next().value)
console.log('main 2')
console.log(gen.next().value)
console.log('main 3')
console.log(gen.next().value)
console.log('main 4')
```

生成器函数的具体使用方式：
在生成器函数内部执行一段代码，如果遇到 yield 关键字，那么 JavaScript 引擎将返回关键字后面的内容给外部，并暂停该函数的执行。外部函数可以通过 next 方法恢复函数的执行。
要搞懂函数为何能暂停和恢复，那你首先要了解协程的概念。`协程是一种比线程更加轻量级的存在`。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，`如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。`

协程的四点规则：
1. 通过调用生成器函数 genDemo 来创建一个协程 gen，创建之后，gen 协程并没有立即执行。
2. 要让 gen 协程执行，需要通过调用 gen.next。
3. 当协程正在执行的时候，可以通过 yield 关键字来暂停 gen 协程的执行，并返回主要信息给父协程。
4. 如果协程在执行期间，遇到了 return 关键字，那么 JavaScript 引擎会结束当前协程，并将 return 后面的内容返回给父协程。

第一点：gen 协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的。第二点：当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息。

```js
function fun1(){
  console.log('fun1')
}
async function foo() {
    console.log(1)
    await fun1();
    let a =  100
    console.log(a)
    console.log(2)
}
console.log(0)
foo()
console.log(3)

// 0 1 fun1 3 100 2 
```
当执行到await fun1();时，碰到await，执行fun1，输出fun1，创建一个 Promise返回给主协程。将返回的promise添加到微任务队列，向下执行 new Promise，输出 promise executor，返回resolve 添加到微任务队列
```js

let promise_ = new Promise((resolve,reject){
  resolve(fun1())
})
```

# 浏览器中的页面
## 21 | Chrome开发者工具：利用网络面板做性能分析
`Chrome 开发者工具（简称 DevTools）是一组网页制作和调试的工具，内嵌于 Google Chrome 浏览器中`
### 网络面板
网络面板由控制器、过滤器、抓图信息、时间线、详细列表和下载信息概要这 6 个区域构成
#### 1. 控制器
- 红色圆点的按钮，表示“开始 / 暂停抓包”，这个功能很常见，很容易理解。
- “全局搜索”按钮，这个功能就非常重要了，可以在所有下载资源中搜索相关内容，还可以快速定位到某几个你想要的文件上。
- Disable cache，即“禁止从 Cache 中加载资源”的功能，它在调试 Web 应用的时候非常有用，因为开启了 Cache 会影响到网络性能测试的结果。
- Online 按钮，是“模拟 2G/3G”功能，它可以限制带宽，模拟弱网情况下页面的展现情况，然后你就可以根据实际展示情况来动态调整策略，以便让 Web 应用更加适用于这些弱网。
#### 2. 过滤器
网络面板中的过滤器，主要就是起过滤功能。因为有时候一个页面有太多内容在详细列表区域中展示了，而你可能只想查看 JavaScript 文件或者 CSS 文件，这时候就可以通过过滤器模块来筛选你想要的文件类型。
#### 3. 抓图信息
抓图信息区域，可以用来分析用户等待页面加载时间内所看到的内容，分析用户实际的体验情况。比如，如果页面加载 1 秒多之后屏幕截图还是白屏状态，这时候就需要分析是网络还是代码的问题了。（勾选面板上的“Capture screenshots”即可启用屏幕截图。）
#### 4. 时间线
时间线，主要用来展示 HTTP、HTTPS、WebSocket 加载的状态和时间的一个关系，用于直观感受页面的加载过程。如果是多条竖线堆叠在一起，那说明这些资源被同时被加载。至于具体到每个文件的加载信息，还需要用到下面要讲的详细列表。
#### 5. 详细列表
这个区域是最重要的，它详细记录了每个资源从发起请求到完成请求这中间所有过程的状态，以及最终请求完成的数据信息。通过该列表，你就能很容易地去诊断一些网络问题。详细列表是我们本篇文章介绍的重点，不过内容比较多，所以放到最后去专门介绍了。
#### 6. 下载信息概要
下载信息概要中，你要重点关注下 DOMContentLoaded 和 Load 两个事件，以及这两个事件的完成时间。DOMContentLoaded，这个事件发生后，说明页面已经构建好 DOM 了，这意味着构建 DOM 所需要的 HTML 文件、JavaScript 文件、CSS 文件都已经下载完成了。Load，说明浏览器已经加载了所有的资源（图像、样式表等）。
通过下载信息概要面板，你可以查看触发这两个事件所花费的时间。

#### 网络面板中的详细列表
下面我们就来重点介绍网络面板中的详细列表，这里面包含了大量有用的信息。
1. 列表的属性
列表的属性比较多，比如 Name、Status、Type、Initiator 等等，这个不难理解。当然，你还可以通过点击右键的下拉菜单来添加其他属性，这里我就不再赘述了，你可以自己上手实操一下。
另外，你也可以按照列表的属性来给列表排序，默认情况下，列表是按请求发起的时间来排序的，最早发起请求的资源在顶部。当然也可以按照返回状态码、请求类型、请求时长、内容大小等基础属性排序，只需点击相应属性即可。
2. 详细信息
如果你选中详细列表中的一项，右边就会出现该项的详细信息，
你可以在此查看请求列表中任意一项的请求行和请求头信息，还可以查看响应行、响应头和响应体。然后你可以根据这些查看的信息来判断你的业务逻辑是否正确，或者有时候也可以用来逆向推导别人网站的业务逻辑。
3. 单个资源的时间线
了解了每个资源的详细请求信息之后，我们再来分析单个资源请求时间线，这就涉及具体的 HTTP 请求流程了。

`第一个是 Queuing`，也就是排队的意思，当浏览器发起一个请求的时候，会有很多原因导致该请求不能被立即执行，而是需要排队等待。导致请求处于排队状态的原因有很多。
- 首先，页面中的资源是有优先级的，比如 CSS、HTML、JavaScript 等都是页面中的核心文件，所以优先级最高；而图片、视频、音频这类资源就不是核心资源，优先级就比较低。通常当后者遇到前者时，就需要“让路”，进入待排队状态。
- 其次，我们前面也提到过，浏览器会为每个域名最多维护 6 个 TCP 连接，如果发起一个 HTTP 请求时，这 6 个 TCP 连接都处于忙碌状态，那么这个请求就会处于排队状态。
- 最后，网络进程在为数据分配磁盘空间时，新的 HTTP 请求也需要短暂地等待磁盘分配结束。

等待排队完成之后，就要进入发起连接的状态了。不过在发起连接之前，还有一些原因可能导致连接过程被推迟，这个推迟就表现在面板中的 `Stalled` 上，它表示停滞的意思。

这里需要额外说明的是，如果你使用了代理服务器，还会增加一个 `Proxy Negotiation` 阶段，也就是代理协商阶段，它表示代理服务器连接协商所用的时间，不过在上图中没有体现出来，因为这里我们没有使用代理服务器。

接下来，就到了 `Initial connection/SSL` 阶段了，也就是和服务器建立连接的阶段，这包括了建立 TCP 连接所花费的时间；不过如果你使用了 HTTPS 协议，那么还需要一个额外的 SSL 握手时间，这个过程主要是用来协商一些加密信息的。（关于 SSL 协商的详细过程，我们会在 Web 安全模块中介绍。）

和服务器建立好连接之后，网络进程会准备请求数据，并将其发送给网络，这就是 `Request sent `阶段。通常这个阶段非常快，因为只需要把浏览器缓冲区的数据发送出去就结束了，并不需要判断服务器是否接收到了，所以这个时间通常不到 1 毫秒。

数据发送出去了，接下来就是等待接收服务器第一个字节的数据，这个阶段称为 Waiting (TTFB)，通常也称为“`第一字节时间`”。 TTFB 是反映服务端响应速度的重要指标，对服务器来说，TTFB 时间越短，就说明服务器响应越快。

接收到第一个字节之后，进入陆续接收完整数据的阶段，也就是 `Content Download` 阶段，这意味着从第一字节时间到接收到全部响应数据所用的时间。

#### 优化时间线上耗时项
1. 排队（Queuing）时间过久
排队时间过久，大概率是由浏览器为每个域名最多维护 6 个连接导致的。那么基于这个原因，你就可以让 1 个站点下面的资源放在多个域名下面，比如放到 3 个域名下面，这样就可以同时支持 18 个连接了，这种方案称为`域名分片`技术。除了域名分片技术外，我个人还建议你把`站点升级到 HTTP2`，因为 HTTP2 已经没有每个域名最多维护 6 个 TCP 连接的限制了。

2. 第一字节时间（TTFB）时间过久
- `服务器生成页面数据的时间过久`。对于动态网页来说，服务器收到用户打开一个页面的请求时，首先要从数据库中读取该页面需要的数据，然后把这些数据传入到模板中，模板渲染后，再返回给用户。服务器在处理这个数据的过程中，可能某个环节会出问题。
- `网络的原因`。比如使用了低带宽的服务器，或者本来用的是电信的服务器，可联通的网络用户要来访问你的服务器，这样也会拖慢网速。
- `发送请求头时带上了多余的用户信息`。比如一些不必要的 Cookie 信息，服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理，这样就加大了服务器的处理时长。

对于这三种问题，你要有针对性地出一些解决方案。面对第一种服务器的问题，你可以想办法去提高服务器的处理速度，比如通过增加各种缓存的技术；针对第二种网络问题，你可以使用 CDN 来缓存一些静态文件；至于第三种，你在发送请求时就去尽可能地减少一些不必要的 Cookie 数据信息。

3. Content Download 时间过久
如果单个请求的 Content Download 花费了大量时间，有可能是字节数太多的原因导致的。这时候你就需要减少文件大小，比如压缩、去掉源码中不必要的注释等方法。

## 22 | DOM树：JavaScript是如何影响DOM树构建的？
### 什么是 DOM
渲染引擎中，DOM 有三个层面的作用。
- 从页面的视角来看，DOM 是生成页面的基础数据结构。
- 从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。
- 从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。

### DOM 树如何生成
在渲染引擎内部，有一个叫 `HTML 解析器（HTMLParser）`的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。
HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。

网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。渲染进程准备好之后，`网络进程和渲染进程之间会建立一个共享数据的管道`，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。

代码从网络传输过来是字节流的形式
字节流转换为 DOM 需要三个阶段
- 第一个阶段，通过分词器将字节流转换为 Token。
- 至于后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。

HTML 解析器维护了一个 `Token 栈结构`，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：
- 如果压入到栈中的是 `StartTag Token`，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。
- 如果分词器解析出来是`文本 Token`，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。
- 如果分词器解析出来的是 `EndTag 标签`，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag  div 从栈中弹出，表示该 div 元素解析完成。

HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时会将一个 StartTag document 的 Token 压入栈底。然后经过分词器解析出来的第一个 StartTag html Token 会被压入到栈中，并创建一个 html 的 DOM 节点，添加到 document 上

### JavaScript 是如何影响 DOM 生成的
解析到<script>标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。

` JavaScript 文件的下载过程会阻塞 DOM 解析`，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。

不过 Chrome 浏览器做了很多优化，其中一个主要的优化是`预解析操作`。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。

` JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，`

## 23 | 渲染流水线：CSS如何影响首次加载时的白屏时间？
### 渲染流水线视角下的 CSS
和 HTML 一样，渲染引擎也是无法直接理解 CSS 文件内容的，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是 CSSOM。和 DOM 一样，CSSOM 也具有两个作用，`第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息`。这个 CSSOM 体现在 DOM 中就是document.styleSheets。
有了 DOM 和 CSSOM，接下来就可以合成布局树了
### 影响页面展示的因素以及优化策略
渲染流水线影响到了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验

从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段。
- 第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容
- 第二个阶段，提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为解析白屏，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。
- 第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。

缩短白屏时长，可以有以下策略：
- 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。
- 但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。
- 还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。
- 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。
## 24 | 分层和合成机制：为什么CSS动画比JavaScript高效？
### 显示器是怎么显示图像的
每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，更新的图片都来自于显卡中一个叫`前缓冲区`的地方，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。
### 总结
渲染引擎生成一帧图像有三种方式：重排、重绘和合成。其中重排和重绘操作都是在渲染进程的主线程上执行的，比较耗时；而合成操作是在渲染进程的合成线程上执行的，执行速度快，且不占用主线程。

## 25 | 页面性能：如何系统地优化页面？

`页面优化，其实就是要让页面更快地显示和响应`

页面有三个阶段：`加载阶段、交互阶段和关闭阶段。`
- 加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。
- 交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。
- 关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作。

### 加载阶段
比如图片、音频、视频等文件就不会阻塞页面的首次渲染；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要用到 CSS 文件。
`这些能阻塞网页首次渲染的资源称为关键资源`

三个影响页面首次渲染的核心因素
1. 第一个是`关键资源个数`。关键资源个数越多，首次页面的加载时间就会越长。
2. 第二个是`关键资源大小`。通常情况下，所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短。
3. 第三个是请求关键资源需要多少个 RTT（Round Trip Time）。当使用 TCP 协议传输一个文件时，比如这个文件大小是 0.1M，由于 TCP 的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。`RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延`。通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。

总的优化原则就是减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数。
- `如何减少关键资源的个数？`一种方式是可以将 JavaScript 和 CSS 改成内联的形式，比如上图的 JavaScript 和 CSS，若都改成内联模式，那么关键资源的个数就由 3 个减少到了 1 个。另一种方式，如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 async 或者 defer 属性；同样对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志。当 JavaScript 标签加上了 async 或者 defer、CSSlink 属性之前加上了取消阻止显现的标志后，它们就变成了非关键资源了。
- `如何减少关键资源的大小？`可以压缩 CSS 和 JavaScript 资源，移除 HTML、CSS、JavaScript 文件中一些注释内容，也可以通过前面讲的取消 CSS 或者 JavaScript 中关键资源的方式。
- `如何减少关键资源 RTT 的次数？`可以通过减少关键资源的个数和减少关键资源的大小搭配来实现。除此之外，还可以使用 CDN 来减少每次 RTT 时长。

### 交互阶段
交互阶段的优化，其实就是在谈渲染进程渲染帧的速度，因为在交互阶段，帧的渲染速度决定了交互的流畅度。
大部分情况下，生成一个新的帧都是由 JavaScript 通过修改 DOM 或者 CSSOM 来触发的。还有另外一部分帧是由 CSS 来触发的。
如果在计算样式阶段发现有布局信息的修改，那么就会触发`重排`操作，然后触发后续渲染流水线的一系列操作，这个代价是非常大的。
同样如果在计算样式阶段没有发现有布局信息的修改，只是修改了颜色一类的信息，那么就不会涉及到布局相关的调整，所以可以跳过布局阶段，直接进入绘制阶段，这个过程叫`重绘`。不过重绘阶段的代价也是不小的
还有另外一种情况，通过 CSS 实现一些变形、渐变、动画等特效，这是由 CSS 触发的，并且是在合成线程上执行的，这个过程称为`合成`。因为它不会触发重排或者重绘，而且合成操作本身的速度就非常快，所以执行合成是效率最高的方式。

优化方案：
`一个大的原则就是让单个帧的生成速度变快。`
`1. 减少 JavaScript 脚本执行时间`
有时 JavaScript 函数的一次执行时间可能有几百毫秒，这就严重霸占了主线程执行其他渲染任务的时间。针对这种情况我们可以采用以下两种策略：
- 一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。
- 另一种是采用 Web Workers。你可以把 Web Workers 当作主线程之外的一个线程，在 Web Workers 中是可以执行 JavaScript 脚本的，不过 Web Workers 中没有 DOM、CSSOM 环境，这意味着在 Web Workers 中是无法通过 JavaScript 来访问 DOM 的，所以我们可以把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行。
`2. 避免强制同步布局`
通过 DOM 接口执行添加元素或者删除元素等操作后，是需要重新计算样式和布局的，不过正常情况下这些操作都是在另外的任务中异步完成的，这样做是为了避免当前的任务占用太长的主线程时间。
`所谓强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中。`
```js

function foo() {
    let main_div = document.getElementById("mian_div")
    let new_node = document.createElement("li")
    let textnode = document.createTextNode("time.geekbang")
    new_node.appendChild(textnode);
    document.getElementById("mian_div").appendChild(new_node);
    //由于要获取到offsetHeight，
    //但是此时的offsetHeight还是老的数据，
    //所以需要立即执行布局操作
    console.log(main_div.offsetHeight)
}
```
将新的元素添加到 DOM 之后，我们又调用了main_div.offsetHeight来获取新 main_div 的高度信息。如果要获取到 main_div 的高度，就需要重新布局，所以这里在获取到 main_div 的高度之前，JavaScript 还需要强制让渲染引擎默认执行一次布局操作。我们把这个操作称为强制同步布局。

`为了避免强制同步布局，我们可以调整策略，在修改 DOM 之前查询相关值。`

`3. 避免布局抖动`
局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。
这种情况的避免方式和强制同步布局一样，都是尽量不要在修改 DOM 结构时再去查询一些相关值。

`4. 合理利用 CSS 合成动画`
合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以要尽量利用好 CSS 合成动画，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。
另外，如果能提前知道对某个元素执行动画操作，那就最好将其标记为 will-change，这是告诉渲染引擎需要将该元素单独生成一个图层。

`5. 避免频繁的垃圾回收`
我们知道 JavaScript 使用了自动垃圾回收机制，如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。
可以尽可能优化储存结构，尽可能避免小颗粒对象的产生。

## 26 | 虚拟DOM：虚拟DOM和实际的DOM有何不同？
### DOM 的缺陷
对于简单的页面来说，其 DOM 结构还是比较简单的，所以以上这些操作 DOM 的问题并不会对用户体验产生太多影响。但是对于一些复杂的页面或者目前使用非常多的单页应用来说，其 DOM 结构是非常复杂的，而且还需要不断地去修改 DOM 树，每次操作 DOM 渲染引擎都需要进行重排、重绘或者合成等操作，因为 DOM 结构复杂，所生成的页面结构也会很复杂，对于这些复杂的页面，执行一次重排或者重绘操作都是非常耗时的，这就给我们带来了真正的性能问题。
### 什么是虚拟 DOM
- 将页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM 上。
- 变化被应用到虚拟 DOM 上时，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。
- 在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。

 React 虚拟 DOM 执行流程
- `创建阶段`。首先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟 DOM 树创建出真实 DOM 树，真实的 DOM 树生成完后，再触发渲染流水线往屏幕输出页面。
- `更新阶段`。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 DOM 树；然后 React 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流水线，并生成新的页面。

从双缓存和 MVC 模型这两个视角来聊聊虚拟 DOM
`1. 双缓存`
可以把虚拟 DOM 看成是 DOM 的一个 buffer，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到 DOM 上，这样就能减少一些不必要的更新，同时还能保证 DOM 的稳定输出。
`2. MVC 模式`
我们可以把虚拟 DOM 看成是 MVC 的视图部分，其控制器和模型都是由 Redux 提供的。其具体实现过程如下：
- 控制器是用来监控 DOM 的变化，一旦 DOM 发生变化，控制器便会通知模型，让其更新数据；
- 模型数据更新好之后，控制器会通知视图，告诉它模型的数据发生了变化；
- 视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟 DOM；
- 新的虚拟 DOM 生成好之后，就需要与之前的虚拟 DOM 进行比较，找出变化的节点；
- 比较出变化的节点之后，React 将变化的虚拟节点应用到 DOM 上，这样就会触发 DOM 节点的更新；
- DOM 节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新。

## 27 | 渐进式网页应用（PWA）：它究竟解决了Web应用的哪些问题？
浏览器的三大进化路线：
- 第一个是应用程序 Web 化；
- 第二个是 Web 应用移动化；
- 第三个是 Web 操作系统化；

PWA，全称是 Progressive Web App，翻译过来就是渐进式网页应用。
PWA:它是一套理念，渐进式增强 Web 的优势，并通过技术手段渐进式缩短和本地应用或者小程序的距离。

### Web 应用  VS  本地应用
Web 缺陷:
- Web 应用缺少离线使用能力，在离线或者在弱网环境下基本上是无法使用的。
- Web 应用还缺少了消息推送的能力，因为作为一个 App 厂商，需要有将消息送达到应用的能力。
- Web 应用缺少一级入口，也就是将 Web 应用安装到桌面，在需要的时候直接从桌面打开 Web 应用，而不是每次都需要通过浏览器来打开。
`针对以上 Web 缺陷，PWA 提出了两种解决方案：通过引入 Service Worker 来试着解决离线存储和消息推送的问题，通过引入 manifest.json 来解决一级入口的问题。`

### 什么是 Service Worker
 Service Worker 是怎么解决离线存储和消息推送的问题。
 ` 它的主要思想是在页面和网络之间增加一个拦截器，用来缓存和拦截请求。`
在没有安装 Service Worker 之前，WebApp 都是直接通过网络模块来请求资源的。安装了 Service Worker 模块之后，WebApp 请求资源时，会先通过 Service Worker，让它判断是返回 Service Worker 缓存的资源还是重新去网络请求资源。一切的控制权都交由 Service Worker 来处理。

## 28 | WebComponent：像搭积木一样构建Web应用
组件化：`对内高内聚，对外低耦合`

### WebComponent 组件化开发
`CSS 和 DOM 是阻碍组件化的两个因素`
WebComponent 给出了解决思路，它提供了对局部视图封装能力，可以让 DOM、CSSOM 和 JavaScript 运行在局部环境中，这样就使得局部的 CSS 和 DOM 不会影响到全局。
`WebComponent 是一套技术的组合，具体涉及到了 Custom elements（自定义元素）、Shadow DOM（影子 DOM）和HTML templates（HTML 模板）`
参考链接：https://developer.mozilla.org/zh-CN/docs/Web/Web_Components

# 浏览器中的网络
## 29 | HTTP/1：HTTP性能优化
HTTP/1.1 为网络效率做了大量的优化，最核心的有如下三种方式：
- 增加了持久连接；
- 浏览器为每个域名最多同时维护 6 个 TCP 持久连接；
- 使用 CDN 的实现域名分片机制。

HTTP 是浏览器中最重要且使用最多的协议，是`浏览器和服务器之间的通信语言`，也是互联网的基石
在诞生之初的 HTTP/0.9 因为需求简单，所以和服务器之间的通信过程也相对简单。由于万维网的快速崛起，带来了大量新的需求，其中最核心的一个就是需要支持多种类型的文件下载， 为此 HTTP/1.0 中引入了请求头和响应头。在支持多种类型文件下载的基础之上，HTTP/1.0 还提供了 Cache 机制、用户代理、状态码等一些基础信息。但随着技术和需求的发展，人们对文件传输的速度要求越来越高，故又基于 HTTP/1.0 推出了 HTTP/1.1，增加了持久连接方法来提升连接效率，同时还尝试使用管线化技术提升效率（不过由于各种原因，管线化技术最终被各大厂商放弃了）。除此之外，HTTP/1.1 还引入了 Cookie、虚拟主机的支持、对动态内容的支持等特性。

## 30｜HTTP/2：如何提升网络速度？
HTTP/2 的解决方案可以总结为：`一个域名只使用一个 TCP 长连接和消除队头阻塞问题。`
HTTP/2 最核心、最重要且最具颠覆性的`多路复用机制`
多路复用是通过在协议栈中添加二进制分帧层来实现的，有了二进制分帧层还能够实现请求的优先级、服务器推送、头部压缩等特性，从而大大提升了文件传输效率。

## 31｜HTTP/3：甩掉TCP、TLS 的包袱，构建高效网络
TTP/2 中所存在的一些问题，主要包括了 TCP 的队头阻塞、建立 TCP 连接的延时、TCP 协议僵化等问题。这些问题都是 TCP 的内部问题，因此要解决这些问题就要优化 TCP 或者“另起炉灶”创造新的协议。由于优化 TCP 协议存在着诸多挑战，所以官方选择了创建新的 QUIC 协议。HTTP/3 正是基于 QUIC 协议的，你可以把 QUIC 看成是集成了“TCP+HTTP/2 的多路复用 +TLS 等功能”的一套协议。这是集众家所长的一个协议，从协议最底层对 Web 的文件传输做了比较彻底的优化，所以等生态相对成熟时，可以用来打造比现在的 HTTP/2 还更加高效的网络。虽说这套协议解决了 HTTP/2 中因 TCP 而带来的问题，不过由于是改动了底层协议，所以推广起来还会面临着巨大的挑战。关于 HTTP/3 的未来，我有下面两点判断：从标准制定到实践再到协议优化还需要走很长一段路；因为动了底层协议，所以 HTTP/3 的增长会比较缓慢，这和 HTTP/2 有着本质的区别。

# 浏览器安全
## 32 | 同源策略：为什么XMLHttpRequest不能跨域请求资源？
浏览器安全可以分为三大块——`Web 页面安全、浏览器网络安全和浏览器系统安全`
比如你打开了一个银行站点，然后又一不小心打开了一个恶意站点，如果没有安全措施，恶意站点就可以做很多事情：
- 修改银行站点的 DOM、CSSOM 等信息；
- 在银行站点内部插入 JavaScript 脚本；
- 劫持用户登录的用户名和密码；
- 读取银行站点的 Cookie、IndexDB 等数据；
- 甚至还可以将这些信息上传至自己的服务器，这样就可以在你不知情的情况下伪造一些转账请求等信息。
所以说，`在没有安全保障的 Web 世界中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据的安全。`
这就引出了页面中最基础、最核心的安全策略：`同源策略（Same-origin policy）`
### 什么是同源策略
`如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源。`
同源策略主要表现在 `DOM、Web 数据和网络`这三个层面

### 安全和便利性的权衡
1. 页面中可以嵌入第三方资源
为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。`CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码`。通过这些手段就可以大大减少 XSS 攻击。

2. 跨域资源共享和跨文档消息机制
`跨域资源共享（CORS）`，使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。
`跨文档消息机制`，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。

### 总结
1. 页面中可以引用第三方资源，不过这也暴露了很多诸如 XSS 的安全问题，因此又在这种开放的基础之上引入了 CSP 来限制其自由程度。
2. 使用 XMLHttpRequest 和 Fetch 都是无法直接进行跨域请求的，因此浏览器又在这种严格策略的基础之上引入了跨域资源共享策略，让其可以安全地进行跨域操作。
3. 两个不同源的 DOM 是不能相互操纵的，因此，浏览器中又实现了跨文档消息机制，让其可以比较安全地通信。

## 33 | 跨站脚本攻击（XSS）：为什么Cookie中有HttpOnly属性？

### 什么是 XSS 攻击
XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。
如果页面被注入了恶意 JavaScript 脚本，恶意脚本都能做哪些事情。
- 可以`窃取 Cookie 信息`。恶意 JavaScript 可以通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给恶意服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。
- 可以`监听用户行为`。恶意 JavaScript 可以使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。黑客掌握了这些信息之后，又可以做很多违法的事情。
- 可以通过`修改 DOM `伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。
还可以`在页面内生成浮窗广告`，这些广告会严重地影响用户体验。

### 恶意脚本是怎么注入的
1. 存储型 XSS 攻击
- 首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中；
- 然后用户向网站请求包含了恶意 JavaScript 脚本的页面；
- 当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。

2. 反射型 XSS 攻击
但当打开http://localhost:3000/?xss=<script>alert('你被xss攻击了')</script>这段 URL 时
用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击。
`Web 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。`

3. 基于 DOM 的 XSS 攻击
基于 DOM 的 XSS 攻击是不牵涉到页面 Web 服务器的。具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。

### 如何阻止 XSS 攻击
1. 服务器对输入脚本进行过滤或转码
- `<script>标签` 转换为 `&lt;script&gt;`
- `<script>标签被转换为&lt;script&gt;` 过滤后 
`code:`

2. 充分利用 CSP
CSP 有如下几个功能：
- 限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；
- 禁止向第三方域提交数据，这样用户数据也不会外泄；
- 禁止执行内联脚本和未授权的脚本；
- 还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。
内容安全策略( CSP )详细文档：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP

3. 使用 HttpOnly 属性
使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。

## 34 | CSRF攻击：陌生链接不要随便点
CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，`CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。`

`和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。`

### 如何防止 CSRF 攻击
1. 充分利用好 Cookie 的 SameSite 属性
https://web.dev/samesite-cookies-explained 。

2. 在服务器端验证请求来源的站点
Referer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址

3. CSRF Token

### 总结
要发起 CSRF 攻击需要具备三个条件：目标站点存在漏洞、用户要登录过目标站点和黑客需要通过第三方站点发起攻击。
如何防止 CSRF 攻击，具体来讲主要有三种方式：充分利用好 Cookie 的 SameSite 属性、验证请求的来源站点和使

## 35 | 安全沙箱：页面和系统之间的隔离墙

## 36 | HTTPS：让数据传输更安全
我们使用 HTTP 传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为`中间人攻击`。

### 在 HTTP 协议栈中引入安全层
通常 HTTP 直接和 TCP 通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信
安全层有两个主要的职责：`对发起 HTTP 请求的数据进行加密操作`和`对接收到 HTTP 的内容进行解密操作`。

### 数字证书
数字证书是由 CA 签名过的，所以浏览器能够验证该证书的可靠性。

## 浏览上下文组：如何计算Chrome中渲染进程的个数？
## 任务调度：有了setTimeOut，为什么还要使用rAF？
## 加载阶段性能：使用Audits来优化Web性能
## 页面性能工具：如何使用Performance？
## 性能分析工具：如何分析Performance中的Main指标？
## HTTPS：浏览器如何验证数字证书？
